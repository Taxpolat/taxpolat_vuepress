---
title: 【Vue】Vue面试题目
date: 2021-09-03
sidebar: 'auto'
author: 'Taxpolat'
categories:
 - Vue
tags:
 - Vue
 - 面试
---

##  vue面试题汇总

### 1. 为什么 data 是一个函数？   
:star::star::star::star::star:
:::tip
组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。
:::
### 2.Vue框架中组件通讯的方式有哪几种？   
:star::star::star::star::star:
:::tip
在一个项目中，组件之间的消息传递，数据互通是非常重要的。   
组件传递数据的场景：
- 父组件 ->子组件间的数据传递
- 子组件 -> 父组件间的数据传递
- 兄弟组件间的数据传递
- 组件深层嵌套，祖先组件与子组件间的数据传递
:::
1. `prop`: 父组件,传递数据, 子组件，接受数据，定义传递数据的类型type与默认值default,require是否必传
2. `$emit`:是子组件传递数据给父组件时可以使用`$emit` 触发事件来做到
3. `$parent`,`$children`:可以直接用`$children`/`$parent`获取当前组件的子组件实例或父组件实例,也能对其做些操作。`$children`是一个数组，里面有个 _uid 属性，可以知道他是第几个元素，是元素的唯一标识符，根据这个属性，我们可以进行其他的操作。（`不推荐使用此方法`）
4. `$attrs` 和`$listeners`:A->B->C的情况使用，
5. 父组件中通过 `provide `来提供变量,然后子组件中通过`inject`来注入变量（`不推荐使用此方法`）
6. `$refs` 获取组件实例并且进行操作
7. `eventBus`:兄弟组件数据传递 这种情况下可以使用事件总线的方式：
   ``` js
    import { EventBus } from "./event-bus.js";

    EventBus.$emit("decreased", {
        num:this.num,
        deg:this.deg
    });
    EventBus.$on("decreased", ({num,deg}) => {
      console.log(num, deg)
    })
   ```
8. `Vuex`状态管理

### 3. Vue 的生命周期方法有哪些 一般在哪一步发请求
:star::star::star::star::star:

1. `beforeCreate` 在实例初始化之后，数据观测(data observer) 和 `event/watcher` 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问
2. `created` 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有`$el`,如果非要想与 Dom 进行交互，可以通过 `vm.$nextTick` 来访问 Dom
3. `beforeMount` 在挂载开始之前被调用：相关的 render 函数首次被调用。
4. `mounted` 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点
5. `beforeUpdate` 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
6. `updated` 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。
7. `beforeDestroy` 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。
8. `destroyed` Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
#### 异步请求在哪一步发起？   
:star::star::star::star:
:::tip
可以在钩子函数 `created、beforeMount、mounted` 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。   
如果异步请求需要依赖 Dom 推荐在 `mounted` 钩子函数中调用异步请求
如果异步请求不需要依赖 Dom 推荐在 `created` 钩子函数中调用异步请求，因为在 `created` 钩子函数中调用异步请求有以下优点：
- 能更快获取到服务端数据，减少页面  loading 时间；
- ssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；
:::




 
<!-- # 1.vue中，app是如何适配的

(1)rem 布局

对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可；对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备

 若没有在根元素（html字体）指定参照值，那浏览器默认1rem就是16px,若指定值，则1rem就是指定值（html设置为62.5%或者10px时会失效，是因为小于12px或者75%的字体大小不支持换算，这可能与有些浏览器不支持12px以下的大小有关）。所以，使用rem单位，html的字体默认字体大小必须设置为12px或以上。若小于12px则浏览器换算时自动默认字体为12px

(2)lib-flexible 插件实现

# 2.computed和watch的区别?什么时候用computed 什么时候用watch 比较合适？

​	**computed计算属性，也就是依赖某个值或者props通过计算得来数据；**

​		1）变量不在 data中定义，而是定义在computed中，写法跟写方法一样，有返回值。函数名直接在页面模板中渲染，不加小括号

​		2）根据传入的变量的变化 进行结果的更新。

​		3）计算属性基于响应式依赖进行缓存。如其中的任意一个值未发生变化，它调用的就是上一次计算缓存的数据，因此提高了程序的性能。而methods中每调用一次就会重新计算一次，为了进行不必要的资源消耗，选择用计算属性。

​	**watch监听器，可以监听某一个数据，然后执行相应的操作；**

​		1）计算属性的时候 初始化的时候就可以被监听到并且计算 但是watch是发生改变的时候才会触发。

​		2）当有一些数据需要随着其它数据变动而变动时，或者当需要在数据变化时执行异步或开销较大的操作时，使用 watch。

​	总结：

​		1）计算属性变量在computed中定义，属性监听在data中定义。

​		2）计算属性是声明式的描述一个值依赖了其他值，依赖的值改变后重新计算结果更新DOM。属性监听的是定义的变量，当定义的值发生变化时，执行相对应的函数。

​		     当多个属性影响一个属性的时候，建议用computed;当一个值发生变化之后，会引起一系列的操作，这种情况就适合用watch；

# 3.v-for中的key是用来做什么的，不使用的话会造成什么/v-for中的key的理解？

需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点,主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果

# 4.VUE双向绑定的原理

vue 双向数据绑定是通过数据劫持结合发布订阅模式的方式来实现的，也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变

# 5.如何理解MVVM模式 -->